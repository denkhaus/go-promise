package Q

import (
	"reflect"
)

type Deferred struct {
	invokable
	targets []reflect.Value
	prev    *Deferred
	next    *Deferred
}

///////////////////////////////////////////////////////////////////////////////////////
// makeDeferred
///////////////////////////////////////////////////////////////////////////////////////
func makeDeferred(parent *Deferred) *Deferred {
	df := &Deferred{prev: parent}
	df.rf = make(ResultFuture)

	if parent != nil {
		parent.next = df
	}

	return df
}

///////////////////////////////////////////////////////////////////////////////////////
// Defer creates a Deferred datatype. A Deferred can be resolved by value or a promise.
///////////////////////////////////////////////////////////////////////////////////////
func Defer(fns ...interface{}) *Deferred {
	df := makeDeferred(nil)
	df.targets = toValueArray(fns)
	return df
}

///////////////////////////////////////////////////////////////////////////////////////
// resolve
///////////////////////////////////////////////////////////////////////////////////////
func (d *Deferred) resolve(init []interface{}) {

	var in []reflect.Value

	if init != nil {
		in = toValueArray(init)
	} else {
		//receive new inputs from prev invocation
		in = d.receiveWithIndex()
	}

	d.invokeAll(d.targets, in)
}

///////////////////////////////////////////////////////////////////////////////////////
// Resolve |
///////////////////////////////////////////////////////////////////////////////////////
func (d *Deferred) Resolve(init ...interface{}) {

	first := func() *Deferred {
		start := d
		for start.prev != nil {
			start = start.prev
		}
		return start
	}

	//start at the beginning of chain
	dStart := first()
	go dStart.resolve(init)

	//resolve all deferreds
	dStart = dStart.next
	for dStart != nil {
		go dStart.resolve(nil)
		dStart = dStart.next
	}
}

///////////////////////////////////////////////////////////////////////////////////////
// Done
///////////////////////////////////////////////////////////////////////////////////////
func (d *Deferred) Done() ([]interface{}, error) {

	last := func() *Deferred {
		start := d
		for start.next != nil {
			start = start.next
		}

		return start
	}

	theLast := last()
	data := theLast.receiveWithIndex()
	return fromValueArray(data), theLast.err
}

///////////////////////////////////////////////////////////////////////////////////////
// Reject
///////////////////////////////////////////////////////////////////////////////////////
func (d *Deferred) Reject(err error) {

}

///////////////////////////////////////////////////////////////////////////////////////
// Deferred Then
///////////////////////////////////////////////////////////////////////////////////////
func (d *Deferred) Then(fns ...interface{}) *Deferred {
	df := makeDeferred(d)
	df.targets = toValueArray(fns)
	return df
}
