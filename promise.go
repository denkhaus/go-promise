package Q

import (
//	"reflect"
)

type Promised struct {
	invokable
	prev *Promised
	next *Promised
}

///////////////////////////////////////////////////////////////////////////////////////
// makePromise
///////////////////////////////////////////////////////////////////////////////////////
func makePromised(parent *Promised) *Promised {
	pr := &Promised{prev: parent}

	if parent != nil {
		parent.next = pr
		pr.pr = parent.pr
	} else {
		pr.pr = NewProgressor()
	}

	pr.rf = make(resultFuture)
	return pr
}

///////////////////////////////////////////////////////////////////////////////////////
// Promise Then
///////////////////////////////////////////////////////////////////////////////////////
func (p *Promised) Then(init ...interface{}) *Promised {
	newP := makePromised(p)

	go func() {
		// old error from prev promises -> stop execution
		if p.err != nil {
			newP.sendError(nil, 0, p.err)
			return
		}

		// wait on result from prev promise
		in := p.receive()
		// and invoke it
		targets := toValueArray(init)
		newP.invokeTargets(targets, in)
	}()

	return newP
}

///////////////////////////////////////////////////////////////////////////////////////
// Done
///////////////////////////////////////////////////////////////////////////////////////
func (p *Promised) Done() []interface{} {
	out := p.receive()
	p.pr.close()
	return fromValueArray(out)
}

///////////////////////////////////////////////////////////////////////////////////////
// OnProgress
///////////////////////////////////////////////////////////////////////////////////////
func (p *Promised) OnProgress(progressFunc ProgressFunc) *Promised {
	p.pr.onProgress(progressFunc)
	return p
}

///////////////////////////////////////////////////////////////////////////////////////
// Finally
///////////////////////////////////////////////////////////////////////////////////////
func (p *Promised) Finally(init interface{}) {
	if p.err != nil {
		return
	}

	in := p.receive()
	//TODO change that, use other toValueArray version
	vals := make([]interface{}, 1)
	vals[0] = init

	targets := toValueArray(vals)
	//TODO close progressor
	go p.invokeTargets(targets, in)
}

///////////////////////////////////////////////////////////////////////////////////////
// Promise
///////////////////////////////////////////////////////////////////////////////////////
func Promise(init ...interface{}) *Promised {
	pr := makePromised(nil)
	targets := toValueArray(init)
	go pr.invokeTargets(targets, nil)
	return pr
}
