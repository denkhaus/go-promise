package promise

import (
	"fmt"
	"reflect"
)

type ParamFuture chan []reflect.Value

type Promise struct {
	pf ParamFuture
}

type Deferred struct {
	pr Promise
}

///////////////////////////////////////////////////////////////////////////////////////
// makePromise
///////////////////////////////////////////////////////////////////////////////////////
func makePromise() *Promise {
	pr := new(Promise)
	pr.pf = make(ParamFuture)
	return pr
}

///////////////////////////////////////////////////////////////////////////////////////
// send
///////////////////////////////////////////////////////////////////////////////////////
func (p *Promise) send(out []reflect.Value) {
	p.pf <- out
}

///////////////////////////////////////////////////////////////////////////////////////
// receive
///////////////////////////////////////////////////////////////////////////////////////
func (p *Promise) receive() (out []reflect.Value) {

	outR := false

	for !outR {
		select {
		case out = <-p.pf:
			outR = true
		}
	}
	return
}

///////////////////////////////////////////////////////////////////////////////////////
// invoke
///////////////////////////////////////////////////////////////////////////////////////
func (p *Promise) invoke(fn interface{}, in []reflect.Value) error {
	v := reflect.ValueOf(fn)
	t := v.Type()

	//check arguments count equal
	if len(in) != t.NumIn() {
		return fmt.Errorf("Function argument count mismatch.")
	}
	//check arguments types equal
	for idx, inVal := range in {
		if inVal.Type() != t.In(idx) {
			return fmt.Errorf("Function argument type mismatch.")
		}
	}

	p.send(v.Call(in))
	return nil
}

///////////////////////////////////////////////////////////////////////////////////////
// Q
///////////////////////////////////////////////////////////////////////////////////////
func Q(init ...interface{}) *Promise {

	pr := makePromise()

	if len(init) == 1 {
		t := reflect.TypeOf(init[0])

		if t.Kind() == reflect.Func {
			//input is init func, invoke it
			go pr.invoke(init[0], []reflect.Value{})
		} else {
			//input is init value, send it directly
			v := reflect.ValueOf(init[0])
			go pr.send([]reflect.Value{v})
		}
	}

	return pr
}

///////////////////////////////////////////////////////////////////////////////////////
// Defer creates a Deferred datatype. A Deferred can be resolved by value or a promise.
///////////////////////////////////////////////////////////////////////////////////////
func (p *Promise) Defer() *Deferred {
	df := &Deferred{pr: *p}
	return df
}

///////////////////////////////////////////////////////////////////////////////////////
// Resolve |
///////////////////////////////////////////////////////////////////////////////////////
func (d *Deferred) Resolve(val interface{}) {

}

///////////////////////////////////////////////////////////////////////////////////////
// Reject
///////////////////////////////////////////////////////////////////////////////////////
func (d *Deferred) Reject(val interface{}) {

}

///////////////////////////////////////////////////////////////////////////////////////
// Deferred Then
///////////////////////////////////////////////////////////////////////////////////////
func (d *Deferred) Then(fns ...interface{}) *Deferred {
	return d
}

///////////////////////////////////////////////////////////////////////////////////////
// Promise Then
///////////////////////////////////////////////////////////////////////////////////////
func (p *Promise) Then(fns ...interface{}) *Promise {
	newP := makePromise()

	go func() {
		// wait on result from prev promise
		out := p.receive()

		// if we have only one Then func, map prev promise outputs to input
		if len(fns) == 1 {
			newP.invoke(fns[0], out)
			return
		}
	}()

	return newP
}

///////////////////////////////////////////////////////////////////////////////////////
// Done
///////////////////////////////////////////////////////////////////////////////////////
func (p *Promise) Done() []interface{} {

	out := p.receive()
	res := make([]interface{}, len(out))

	for idx, val := range out {
		res[idx] = val.Interface()
	}

	return res
}

///////////////////////////////////////////////////////////////////////////////////////
// Finally
///////////////////////////////////////////////////////////////////////////////////////
func (p *Promise) Finally(fn interface{}) {
	out := p.receive()

	t := reflect.TypeOf(fn)
	if t.Kind() == reflect.Func {
		pr := makePromise() //dummy
		go pr.invoke(fn, out)
	}
}
